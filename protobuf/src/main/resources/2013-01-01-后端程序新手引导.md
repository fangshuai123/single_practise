---
tags: [新手引导]
layout: post
category: 新手引导
title: 新手引导
tagline: 
---

每新到一个童鞋，都需要有导师引导，快速加入我们的后端团队，这中间有很多需要重复枯燥的内容，这里整理成文档，以便批量生产。

欲练此功，必先学习基础知识（不是自宫）

### 基础知识

#### protobuf

学习资料

    开发者：https://developers.google.com/protocol-buffers/
    （可能需要翻墙才能看到）

    代码（可以不用看）：https://github.com/google/protobuf

目的

    通过此处学习，学员可以自行搭建protobuf环境，当开发环境中得protobuf出现问题时候，可以自行解决。

输出内容

    1、编写一个proto文件
    2、通过搭建的编译环境，将proto编译成代码

由导师验收

额外的内容（课外内容），protobuf如何编译成as代码

### 线程模型

可以这么说，只有理解了线程模型，写出来的服务器代码才是正确地代码。

服务器存在3个线程池，

    定时线程池，负责处理定时执行的任务和延时执行的任务
    英雄线程池，负责英雄数据的处理
    DB线程池，负责不需要在英雄线程执行或在其他的长耗时的任务

线程池关闭顺序，定时线程池 -> 英雄线程池 -> db线程池

约定

    定时线程池可以往英雄线程池或者DB线程池提交任务
    英雄线程池可以往DB线程池提交任务，往定时线程池提交任务，需要处理异常(因为定时线程池可能已经关闭了)
    DB线程池往定时线程池或者英雄线程池提交任务时候，需要处理异常

#### 定时线程池 和 DB线程池

java类库中提供的，不做深入说明

#### 英雄线程池

这个是我们的重点，这是一个disruptor实现的线程池（后面有说disruptor的资料），定长线程池（这个很重要，记住这是个定长线程池），RingBuffer实现，也就是说，当线程池满了，往线程池提交任务线程将会blocking或者失败(取决于你调的方法)

英雄线程池是一个单线程的线程池，每个线程池只有一个线程，服务器会根据CPU开启多个英雄线程池，每个英雄线程池被多个英雄共享，同一个英雄，他每次使用的线程池都是同一个（知道为什么怎么做吗）

    想知道每个英雄是怎么获取固定线程池吗，答案就是id，英雄有一个id，线程池有一个id，线程池id是连续的，英雄id % 线程池总数 就得到了这个英雄所属的线程id
    你以为我们就是这样做得吗，我们用 & 哈哈...

因为英雄使用的线程永远是同一个，所以不需要担心多线程问题，英雄数据的修改，英雄数据的保存，都发生在单线程中，这样使得编码变得很简单，但是要注意一个问题，英雄数据只能在英雄线程中修改，这是一个很重要的问题，一定要记住。

    不是所有英雄数据都是在英雄线程中修改的，但是这需要你具备很吊的多线程经验，以后你会发现这样的代码的

结束上面的问题思考后，我们来说一下，在当前的线程模型下，如何在英雄线程之间交互

假设需求是这样的，英雄A和英雄B组队，他们杀怪的经验是共享的，也就是英雄A线程需要给英雄B加经验，或者相反，我们的做法是，disruptor
每个英雄线程配备一个RingBuffer，其他线程可以向这个RingBuffer提交任务，英雄线程定时处理RingBuffer的数据。但是RingBuffer有个问题，还记得吗，这货是个定长的，一旦这个池子满了，则会提交失败，在这里如果失败了，我们就不处理，因为这个不是很重要的事情（失败了只是导致了没有加到经验而已，这个不太重要的）

假设需求是这样的，英雄加入帮派后（帮派等级=1），要给英雄额外加100点血，帮派等级越高，额外加的血量越多，帮派等级由帮主消耗铜钱升级，这个属性要怎么做？（提示，由于帮派内很多人，帮主升级后，所有人的属性都要增加，但是每个英雄的线程都可能不一样）

处理类似的问题的另一种方案就是轮询，英雄中有各种轮询执行的代码，100毫秒执行一次，1秒钟执行一次，1分钟执行一次，1天执行一次等等，

基本上这些知识可以足够你处理大部分的需求了，更高要求的使用场景，遇到的时候，跟导师进行讨论吧

disruptor学习资料 imax

目的

    理解线程模型，熟悉当前线程模型下，跨线程交互如何处理

输出

以下问题的解答

    英雄线程可以往自己的线程池提交任务吗，为什么？英雄线程可以往除自己外的其他英雄线程池提交任务吗，为什么？
    不可以，若ringbuffer写满了，自己会提交失败，然后自己若等待重试的话，线程会死锁。
    不可以，若两个英雄在一个线程池，则跟上面的情况一致；若在不同线程池，相互提交任务时，若恰好两个的ringbuffer都满了，就死锁。
    假设怪物A死亡后（死亡逻辑在DB线程中执行），给全服所有的英雄加100经验，此时应该怎么做？
    DB线程向每一个RingBuffer提交任务，加100经验。但是会有可能失败，当RingBuffer满了时。异常时重试。
    向每一个

    


### 登陆流程

目前游戏登陆过程分成4个过程

    平台方发起登陆跳转，如 http://s1.gjqt.baidu.com/baidu/login?sid=1&uid=1&sign=jn8c68m5zc85c79s65789xzc6r，其中平台方需要将域名s1.gjqt.baidu.com解析到游戏服所在的服务器
    
    游戏服配置nginx跳转，将请求转到游戏服监听的http端口上，比如8201，游戏服有对应的处理类 *LoginHandler处理, 具体可以参考 BaiduLoginHandler.java

    游戏服收到平台登录跳转后，返回给浏览器我们的客户端加载地址，并且附带上服务器地址、登陆操作所需的信息，浏览器负责加载客户端程序以及资源

    客户端程序加载后，执行登陆逻辑，发送登陆消息到服务器，服务器检查参数后，发送登陆成功，让玩家进入场景（发送场景内容），广播给其他人有新玩家进入

目的

    理解游戏登陆流程

输出

    接入一个新平台（导师提供一份平台接入文档）

### 进入场景流程

    服务器在某个点（比如客户端请求去新场景，或者服务器认为此时应该去新场景时），给客户端发送切换场景消息

    客户端收到切换场景消息后，开始加载新场景资源，并且显示切场景进度（不是必须，目的是告诉玩家当前在切场景），加载完成后，发送加载完成消息给服务器，服务器将玩家加入到新场景中，发送场景信息给玩家，并且广播新玩家加入

目的

    理解玩家如何从一个场景进入到另外一个场景的过程

输出

    一个简单的副本，通过GM命令进入，副本中一个boss，击败boss后，掉落一个物品

### 成长系统

比如坐骑，翅膀等系统

    进游戏玩2下就知道了

目的

    理解成长系统的基本内容，熟悉属性，战斗力，外观模型如何表示

输出

    完成一个坐骑系统，25级免费领取1级马，实现进阶，上下马，外观，属性，战斗力等加成

### HashMap

    HashMap在多线程调用的情况下，会出现死循环，因此不要在多线程环境下使用HashMap

    自己线程put，其他线程put，不行

    自己线程get，其他线程put，不行

    自己线程put，其他线程get，不行

    唯一可以多线程使用的情况是，初始化后，所有线程都只做get，这个是ok的

唯一的要求，记住HashMap多线程访问会造成死循环，不要在代码中这样做。












